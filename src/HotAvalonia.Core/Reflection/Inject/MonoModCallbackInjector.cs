using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using HotAvalonia.Helpers;

namespace HotAvalonia.Reflection.Inject;

/// <summary>
/// Provides callback injection capabilities by delegating all the hard work to the <c>MonoMod.RuntimeDetour</c> library.
/// </summary>
internal sealed class MonoModCallbackInjector : RuntimeCallbackInjector
{
    private static readonly Func<MethodBase, MethodInfo, object?, IDisposable>? s_createHook;

    static MonoModCallbackInjector()
    {
        s_createHook = null;
        if (!AssemblyHelper.TryLoad("MonoMod.RuntimeDetour", out Assembly? runtimeDetour))
            return;

        Type? hookType = runtimeDetour.GetType("MonoMod.RuntimeDetour.Hook");
        ConstructorInfo? hookCtor = hookType?.GetConstructor([typeof(MethodBase), typeof(MethodInfo), typeof(object)]);
        if (hookCtor is null)
            return;

        // MonoMod starts spamming debug logs if it detects a debugger attached to the current process.
        // While this is useful when debugging a mod, it's a really annoying anti-feature in our context,
        // as it drastically slows everything down. Thus, disable it as soon as humanly possible.
        object? logger = Type.GetType("MonoMod.Logs.DebugLog, MonoMod.Utils")?.GetField("Instance", (BindingFlags)(-1))?.GetValue(null);
        logger?.GetType().GetField("globalFilter", (BindingFlags)(-1))?.SetValue(logger, 0);

        // Even if `MonoMod.RuntimeDetour` is present, it does not necessarily mean we will be able to use it,
        // as it may simply not support the current environment (for example, at the time of writing, there is
        // no support for Arm64 yet).
        // To account for this possibility, we check the `PlatformTriple.Current` property:
        // attempting to access it in an unsupported environment will result in an exception.
        try
        {
            using IDisposable context = AssemblyHelper.ForceAllowDynamicCode();
            Type? platformTriple = Type.GetType("MonoMod.Core.Platforms.PlatformTriple, MonoMod.Core");
            if (platformTriple?.GetProperty("Current", (BindingFlags)(-1))?.GetValue(null) is null)
                return;
        }
        catch
        {
            return;
        }

        // Dynamic code generation must be enabled, as it is required for MonoMod to function.
        // Note that we cannot enable it just once and call it a day,
        // because this setting only affects the current thread.
        _ = AssemblyHelper.ForceAllowDynamicCode();

        Action<object, MethodBase, MethodInfo, object?> initHook = hookCtor.CreateUnsafeDelegate<Action<object, MethodBase, MethodInfo, object?>>();
        s_createHook = (target, callback, thisArg) =>
        {
            _ = AssemblyHelper.ForceAllowDynamicCode();
            IDisposable hook = Unsafe.As<IDisposable>(RuntimeHelpers.GetUninitializedObject(hookType!));
            initHook(hook, target, callback, thisArg);
            return hook;
        };
    }

    /// <summary>
    /// Gets a value indicating whether this injector is supported in the current environment.
    /// </summary>
    public static bool IsSupported => s_createHook is not null;

    public override InjectionType InjectionType => InjectionType.MonoMod;

    public override bool CanInjectInto([NotNullWhen(true)] MethodBase? target)
        => target is { IsGenericMethod: false, DeclaringType: not { IsGenericType: true } };

    protected override IDisposable CreateHook(MethodBase target, MethodInfo callback, object? thisArg = null)
        => s_createHook!(target, callback, thisArg);

    protected override bool RequiresCallbackTrampoline(CallbackInfo callback)
    {
        // MonoMod will throw a tantrum if we attempt to bind a static method to an object,
        // even though runtime semantics absolutely do allow it.
        if (callback.Callback.IsStatic != callback.FirstArgument is null)
            return true;

        // A trampoline generated by MonoMod's Hook does not automatically pop an unwanted return value.
        if (callback.GetTargetReturnType() == typeof(void) && callback.GetCallbackReturnType() != typeof(void))
            return true;

        // The expected signature is: (TThis @this, TDelegate originalMethod, TArg0 arg0, ..., TArgN argN).
        // The first two parameters are optional, but all of the original method's arguments are not.
        ReadOnlySpan<ParameterInfo> parameters = callback.GetTargetParameters();
        ReadOnlySpan<CallbackArgument> args = callback.GetCallbackArguments();
        if (args is [{ Type: CallbackArgumentType.BoundObject }, ..])
            args = args[1..];
        if (args is [{ Type: CallbackArgumentType.Delegate }, ..])
            args = args[1..];

        if (args.Length != parameters.Length || args is not ([] or [{ Type: CallbackArgumentType.Argument, Index: 0 }, ..]))
            return true;

        for (int i = 1; i < args.Length; i++)
        {
            ref readonly CallbackArgument arg = ref args[i];
            if (arg.Type != CallbackArgumentType.Argument || arg.Index != args[i - 1].Index + 1)
                return true;
        }
        return false;
    }

    protected override MethodBuilder DefineCallbackTrampoline(TypeBuilder builder, string name, CallbackInfo callback, out int extraParametersCount)
    {
        extraParametersCount = 0;
        ReadOnlySpan<ParameterInfo> parameters = callback.GetCallbackParameters();
        ReadOnlySpan<CallbackArgument> arguments = callback.GetCallbackArguments();
        ParameterInfo? delegateParameter = null;
        for (int i = 0; i < arguments.Length; i++)
        {
            if (arguments[i].Type is not CallbackArgumentType.Delegate)
                continue;

            extraParametersCount = 1;
            delegateParameter = parameters[i];
            break;
        }

        Type returnType = callback.GetTargetReturnType();
        ParameterInfo[] trampolineParameters = delegateParameter is null ? [.. callback.GetTargetParameters()] : [delegateParameter, .. callback.GetTargetParameters()];
        Type[] trampolineParameterTypes = Array.ConvertAll(trampolineParameters, static x => x.ParameterType);
        return builder.DefineMethod(name, MethodAttributes.Public | MethodAttributes.Static, returnType, trampolineParameterTypes);
    }

    protected override void LoadDelegate(ILGenerator il, MethodBase target, Type delegateType, ref Action<IDisposable> ctor, MethodBuilder dispose)
        => il.Emit(OpCodes.Ldarg_0);
}
